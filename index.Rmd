---
title: "Colorado Water Rights"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    logo: www/lynker_logo_white_transparent.png
    css: www/custom.css
runtime: shiny
---

<style>

.navbar, [data-toggle=tab], .navbar-brand  {   background-color:#1c3a5d;   border-color:black;   color:white; }

</style>

```{r setup, include = FALSE}
# Shiny & Flexdashboard packages
library(shiny)
library(flexdashboard)

# Data manipulation
library(dplyr)
library(ggplot2)
library(gt)

# Mapping packages
library(leaflet)

# geospatial and climate data
library(terra)
library(climateR)

library(shinyBS)

# Load function data_utils.R file
source('final_utils.R')
```

```{r context="server"}
# # water rights data
# water_rights <- readr::read_csv("detrended_all_data_final_v2.csv")

# linear regression lookup table
lm_lookup <- readRDS("cpo_linear_regression_lookup.rds")
# lm_lookup <- readr::read_csv("cpo_linear_regression_lookup_v2.csv")
# saveRDS(lm_lookup, "cpo_linear_regression_lookup.rds")

# subset of districts
dists <- sf::read_sf("water_districts_subset.gpkg")

# catalog entry for getting EDDI data
cat <- readRDS("eddi_catalog.rds") %>% 
  update_duration()

# # get new EDDI 30 Day data when application loads
new_eddi <- eddi_from_catalog(
  catalog    = cat,
  aoi        = dplyr::mutate(dists,
                             district = as.integer(district)),
  varname    = c("eddi30d", "eddi1y"),
  # varname    = "eddi30d",
  start_date = Sys.Date() - 365,
  end_date   = Sys.Date(),
  name_col   = "district",
  verbose    = FALSE
  )

# saveRDS(new_eddi, "updated_eddi_data.rds")
# new_eddi <- readRDS("updated_eddi_data.rds")

# average yeartype data
# avg_yeartype <- readRDS("avg_weekly_calls_by_yeartype2.rds")
avg_yeartype <- readRDS("avg_weekly_calls_by_yeartype.rds") %>% 
     dplyr::mutate(
      year_type = factor(year_type, levels = c("Dry", "Average", "Wet"))
    )

# data used to generate linear regression models
mod_df <- readRDS("mlr_model_data.rds")

#  list of linear regression models and metrics
lm_list <- readRDS("mlr_model_list.rds")

# lm_list <- make_lm_list(df = mod_df)
# saveRDS(lm_list, "data/lin_reg_model_list.rds")

# lm_list <- readRDS("data/lin_reg_model_list2.rds")
# lm_out <- make_lm(model_data = dist_mod_df())

# base leaflet map on page 1
output$baseMap       <- leaflet::renderLeaflet({ dist_basemap(shp = dists) })

# Model base leaflet map on page 2
output$modelBaseMap       <- leaflet::renderLeaflet({ model_basemap(shp = dists) })
```

```{r context="server"}
map_click <- shiny::reactive({
   input$baseMap_click
})
```

```{r context="server"}
date_input <- shiny::reactive({
   input$dateInputVal
})
```

```{r context="server"}
dist_id <- shiny::reactive({
   input$baseMap_shape_click$id
})

```

```{r context="server"}
sub_dist1 <- shiny::reactive({
    # subset to water district of interest
    if(is.null(dist_id()) | dist_id() == " ") {
      
      return(NULL)
      
    } else {
         dists[dists$district == dist_id(), ]
    }
  
})
```

```{r, context = "server"}
model_dist_id <- shiny::reactive({
   # as.numeric(input$baseMap_shape_click$id)
   input$modelBaseMap_shape_click$id
})
```

```{r context="server"}
# subset district polygon based on districtInput
sub_dist2 <- shiny::reactive({
    # subset to water district of interest
    if(is.null(model_dist_id())) {

      return(NULL)

    } else {
      dists[dists$district == model_dist_id(), ]
    }

})
```

```{r context="server"}
# # list ID for lm_list of lin reg models
list_id <- shiny::reactive({

  # if(is.null(model_dist_id()) | model_dist_id() == " ") {
  if(is.null(model_dist_id())) {
    # return(" ")
    return(NULL)

  } else {

    paste0("district_", model_dist_id())

  }

})
```

```{r context="server"}
call_year_df <- shiny::reactive({
  avg_yeartype %>% 
    dplyr::filter(district == dist_id())
})
```

```{r context="server"}
dist_mod_df <- shiny::reactive({
  mod_df %>% 
    dplyr::filter(district == model_dist_id())
    # dplyr::filter(district == dist_id(), 
    #               year_type == input$radioYearTypeButtons)
})
```

```{r context="server"}
eddi_df <- shiny::reactive({
  new_eddi %>% 
    dplyr::filter(district == model_dist_id())
})
```

```{r context="server"}
# EDDI variable name for selected district
eddi_variable <- shiny::reactive({

  if(is.null(model_dist_id())) {
    return("")
  } else {
    return(
      dplyr::filter(
        lm_lookup,
        district == model_dist_id())$predictor_name2
      )
    
  }
})
```

```{r context="server"}
# EDDI value for selected district
eddi_val <- shiny::reactive({
    
  if(is.null(model_dist_id())) {
    return(0)
  } else {
    return(
      dplyr::filter(new_eddi, 
                    district == model_dist_id())[[eddi_variable()]]
      )
    
  }
})
```

```{r context="server"}
lm_data <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(list_id())) {
    return(NULL)
  } else {
    return(lm_list[[list_id()]])
  }
})
```

```{r context="server"}
model_data <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(lm_data())) {
    return(NULL)
  } else {
    return(lm_data()$model_data)
  }
})
```

```{r context="server"}
model_obj <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(lm_data())) {
    return(NULL)
  } else {
    return(lm_data()$model)
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_str1 <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor1[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_str2 <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor2[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_str <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_long_str <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor_long_name[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_units <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    # lm_lookup$units1[lm_lookup$district == "01"]
    return(lm_lookup$units1[lm_lookup$district == model_dist_id()])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_str_units <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
      return(
        paste0(
          model_data()$predictor_long_name[1],
          " (", predictor_units(), ") "
          )
        )
  }
})

```

```{r context="server"}
# string containing the predictor for the given district
predictor_long_str2 <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor_long_name2[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
primary_pred_valuebox_label <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.na(as.numeric(input$newDataInput))) {
    
    return(" ")
    
  } else {
    
    return(   
      round(as.numeric(input$newDataInput), 2)
      )
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
eddi_pred_valuebox_label <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(eddi_val() == 0) {
    
    return(" ")
    
  } else {
    
    return(   
      round(eddi_val(), 2)
      )
  }
})
```

```{r context="server"}
# # string containing the predictor for the given district
predictor_label <- shiny::reactive({

  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(predictor_long_str())) {

    return(paste0("Enter a predictor value after selecting a district..."))

  } else {

    return(paste0("Enter ", predictor_str_units(), " value..."))
    
    # this does NOT work
    # bold_text <- paste0("<strong>", predictor_long_str(), "</strong>")
    # return(HTML(paste0("Enter ", bold_text, " value...")))

    # # this does NOT work
    # return(paste0("Enter <strong>", predictor_str_units(), "</strong> value..."))

  }
})
```

Right-o-graph
==========================================

Inputs {.sidebar}
---------------------------------------------------------
<strong>Click on a district on the map to begin.</strong>

In Colorado, when a shortage occurs, senior water rights-holders may place a “call” on the river. Every water rights user has a priority date, or the date the water right was established. The year of that right is called a “call year”. The plot to the right shows the average call year of the senior water rights-holder who placed a “call” on the river for every day of the year. 

The data comes from 34 individual WDIDs across 12 water districts in Colorado's South Platte River basin. WDIDs were selected by locating the most upstream water users along the mainstem rivers within each water district.  

<br>

```{r}
# shiny::radioButtons(
#   inputId  = "radioYearTypeButtons",
#   label = "Water year type:",
#   choices = c(
#     "Dry"    = "Dry",
#    "Average" = "Average",
#    "Wet"     = "Wet"
#    ),
#   selected = "Average"
#   )
```

Column {data-width=500}
---------------------------------------------------------
### District
```{r}
# 
# shinyjs::onevent("hover", id = "districtValueBoxMap1")
#  onclick('clickdiv', showModal(modalDialog(
#     title = "Your title",
#     renderDataTable(data)
#   )))

# flexdashboard::valueBoxOutput("districtValueBoxMap1") %>% 
#   bsplus::bs_embed_tooltip(title = "I'm a tooltip", placement = "bottom")

flexdashboard::valueBoxOutput("districtValueBoxMap1") 
shinyBS::bsPopover(
  "districtValueBoxMap1",
  title     = "",
  content   = "Water district",
  placement = "bottom",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
output$districtValueBoxMap1 <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("District: "),
    color = "primary",
    caption = " "
    )
)

# Value box server
shiny::observeEvent(dist_id(), {
  
      # Public Safety value box server
      output$districtValueBoxMap1 <- flexdashboard::renderValueBox(

        flexdashboard::valueBox(
          value = paste0("District: ", dist_id()),
          color = "primary",
          caption = " "
          )
        )
})
```

### 
```{r}
# District leaflet map output
leaflet::leafletOutput("baseMap")
# shinyBS::bsPopover(
#   "baseMap",
#   title     = "Colorado South Platte Water Districts",
#   content   = "Click on a water district to view annual historical call dates for a given week",
#   placement = "right",
#   options   = list(container = "body")
#   )
# tags$style(HTML("
#                 .tooltip > .tooltip-inner {
#                 width: 400px;
#                 color: black;
#                 background-color: white;
#                 }
#                 "))
```

```{r context="server"}
# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# observeEvent(input$districtMapMLR_click, {
shiny::observeEvent(input$baseMap_shape_click, {
# shiny::observeEvent(input$baseMap_click, {
   if(is.null(dist_id())) {

     return(NULL)

   } else {

          print(paste0("Subsetting mainstems to HUC4: ",  dist_id()))

          print("Subsetting WDIDs to district area...")

          print("Updating leaflet map...")

          # dynamically alter leaflet map
          leaflet::leafletProxy("baseMap") %>%
              leaflet::clearMarkers() %>%
              leaflet::clearShapes() %>%
              leaflet::clearGroup(c("subdist1")) %>%
                # leaflet::removeShape(layerId = levelpathi) %>%
                leaflet::addPolygons(
                      data         = dists,
                      fillColor    = 'white',
                      # fillColor = 'grey',
                      # fillColor = ~pal_fact(BASIN),
                      fillOpacity  = 0.7,
                      col          = "black",
                      opacity      = 1,
                      weight       = 2.5,
                      label        = ~paste0("District: ", district),
                      layerId      = ~district,
                      labelOptions = leaflet::labelOptions(
                                          noHide = F,
                                          style  = list(
                                            "color" = "black",
                                            "font-weight" = "1000")
                                        )
                  ) %>%
                leaflet::addPolygons(
                    data = sub_dist1(),
                    fillColor    = '#3EB489',
                    fillOpacity  = 0.5,
                    col          = "black",
                    opacity      = 1,
                    weight       = 3,
                    group        = "subdist1",
                    label        = ~paste0("District: ", district),
                    layerId      = ~district,
                    labelOptions = leaflet::labelOptions(
                                        noHide = F,
                                        style  = list(
                                          "color" = "black",
                                          "font-weight" = "1000")
                                      )
                )

             shiny::observe({

                  if(is.null(dist_id())) {

                       return(NULL)
             #
                     } else {
            
                     # render call date over time plot
                     output$callDatePlot <- shiny::renderPlot({
                       
                        make_yeartype_rightograph_plot(
                          df    = call_year_df()
                          )
                        # make_avg_yeartype_rightograph_plot(
                        #   df    = call_year_df(),
                        #   type  = input$radioYearTypeButtons
                        #   )

                        })
                       }
               })
             }
          })
```

Column {data-width=500}
---------------------------------------------------------
###
```{r}
shiny::plotOutput("callDatePlot")
shinyBS::bsPopover(
  id = "callDatePlot",
  title     = "Average call years by year type",
  content   = "Each timeseries shows  the year of the appropriation date of the senior water user placing a call on the river. The senior water user may be located in a downstream district. Depending on the hydrologic year type (Wet, Dry, or Average), the appropriation year of the senior water rights-holder placing the call on the river changes.",
  placement = "left",
  trigger = "hover",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
# Column {data-width=500}
# shiny::plotOutput("callDatePlot") %>% 
   # bsplus::bs_embed_tooltip(
   #   title = "After clicking on a district on the map above, a lineplot showing the selected district's historic average call date (Y axis) for a given week of the year (X axis). The 3 lines each represent a different average value calculated for across all years for a given year type (dry, average, and wet). Year types were calculated by creating terciles from the annual total streamflow discharge volume at a representative USGS gage for each district.", 
   #   placement = "left"
   #   )
```

Regression models 
==========================================

Inputs {.sidebar}
---------------------------------------------------------
<strong>Click on a district on the map to begin.</strong>

A multiple linear regression was performed for each district. The top performing predictor variables include:

- May 1st SWE

- NRCS May 1 Apr-Sep forecast

- Peak SWE

- EDDI

The model parameters and performance for each district is displayed in the table to the right. 

<br>

<strong>Prediction Tool:</strong>
Current EDDI is provided. To predict an average summer call year, enter a value for the second predictor variable in the box below.

<br>

```{r, context = "server"}
# instructions text: 
# Use the dropdown menu below to select a water district from the map on the right.
# shiny::selectizeInput(
#   inputId = "districtInput",
#   label   = "Select a district",
#   choices = c("1" = "01", "2" = "02", 
#               "3" = "03",  "4" = "04", 
#               "5" = "05", "6" = "06",
#               "7" = "07", "8" = "08",
#               "9" = "09","23" = "23",
#               "64" = "64", "80" = "80" ),
#   multiple = TRUE, 
#   options = list(maxItems = 1)) 
```



```{r, context = "server"}
shiny::textInput(inputId = "newDataInput", 
                 # label = predictor_label(),
                 label   = "...",
                 # label   = ifelse(
                 #              is.null(predictor_str()), 
                 #              "Select a district to make a provide SWE/NRCS Forecast data...", 
                 #              paste0("Enter ", predictor_str(), " value...")
                 #                   ),
                 value   = NULL,
                 placeholder = NULL
                 )

shiny::actionButton("newDataInputButton",
                    label = "Predict")

shiny::observeEvent(predictor_label(), {
    shiny::updateTextInput(session,
                           "newDataInput", 
                           label = predictor_label(),
                           placeholder = predictor_long_str()
                           )
  })
```

<br>

Column {data-width=500}
---------------------------------------------------------
### District
```{r}
flexdashboard::valueBoxOutput("districtValueBoxMap2")
shinyBS::bsPopover(
  "districtValueBoxMap2",
  title     = "",
  content   = "Water district",
  placement = "bottom",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
# {r context="server"}
# flexdashboard::valueBox(value = model_dist_id())
# ("primary", "info", "success", "warning", "danger")
output$districtValueBoxMap2 <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("District: "),
    color = "primary",
    caption = " "
    )
)

# Value box server
shiny::observeEvent(model_dist_id(), {
# shiny::observeEvent(event_trigger(), {
      # print("observer4")

      # Public Safety value box server
      output$districtValueBoxMap2 <- flexdashboard::renderValueBox(
        flexdashboard::valueBox(
          value = paste0("District: ", model_dist_id()),
          color = "primary",
          caption = " "
          )
        )

})
```

###
```{r}
leaflet::leafletOutput("modelBaseMap")
# shinyBS::bsPopover(
#   "modelBaseMap",
#   title     = "Colorado South Platte Water Districts",
#   content   = "Use the selection drop down in the left panel to select and highlight a water district on the map",
#   placement = "right",
#   options   = list(container = "body")
#   )
# tags$style(HTML("
#                 .tooltip > .tooltip-inner {
#                 width: 400px;
#                 color: black;
#                 background-color: white;
#                 }
#                 "))
```

```{r context="server"}
# # # Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# # # observeEvent(input$districtMapMLR_click, {
# # shiny::observeEvent(input$modelBaseMap_shape_click, {
shiny::observeEvent(model_dist_id(), {
   if(is.null(model_dist_id())) {

     return(NULL)

   } else {

       
          #  print(paste0("Map 2 latitude ---> ", model_map_click()$lat))
          #  print(paste0("Map 2 longitude ---> ", model_map_click()$lng))
          # # print(paste0("Subsetting mainstems to HUC4: ",  model_dist_id()))
          # print(paste0("Page 2 district selection ---> ", model_dist_id()))
          # 
          # print(paste0("Highlighting district ", model_dist_id(), " based on districtInput change..."))

          # # subset to water district of interest
          # sub_dist2 <- dists[dists$DISTRICT == model_dist_id(), ]
     
          print(paste0("===== model_dist_id: ", model_dist_id(), " ====="))
     
          print(paste0("===== predictor_str(): ", predictor_str(), " ====="))
          print(paste0("===== predictor_label(): ", predictor_label(), " ====="))
          
          print(paste0("===== predictor_str2(): ", predictor_str2(), " ====="))
          print(paste0("===== predictor_long_str2(): ", predictor_long_str2(), " ====="))
          
          print(paste0("===== eddi_variable(): ", eddi_variable(), " ====="))
          print(paste0("===== eddi_val(): ", eddi_val(), " ====="))
          
          print("Updating leaflet map...")

          # dynamically alter leaflet map
          leaflet::leafletProxy("modelBaseMap") %>%
              leaflet::clearMarkers() %>%
              leaflet::clearShapes() %>%
              leaflet::clearGroup(c("subdist2")) %>%
                # leaflet::removeShape(layerId = levelpathi) %>%
                leaflet::addPolygons(
                      data         = dists,
                      fillColor    = 'white',
                      # fillColor = 'grey',
                      # fillColor = ~pal_fact(BASIN),
                      fillOpacity  = 0.7,
                      col          = "black",
                      opacity      = 1,
                      weight       = 2.5,
                      label        = ~paste0("District: ", district),
                      layerId      = ~district,
                      labelOptions = leaflet::labelOptions(
                                          noHide = F,
                                          style  = list(
                                            "color" = "black",
                                            "font-weight" = "1000")
                                        )
                  ) %>%
                leaflet::addPolygons(
                      # data         = sub_dist2,
                    data         = sub_dist2(),
                    fillColor    = '#3EB489',
                    # fillColor = 'grey',
                    # fillColor = ~pal_fact(BASIN),
                    fillOpacity  = 0.5,
                    col          = "black",
                    opacity      = 1,
                    weight       = 3,
                    group        = "subdist2",
                    label        = ~paste0("District: ", district),
                    layerId      = ~district,
                    labelOptions = leaflet::labelOptions(
                                        noHide = F,
                                        style  = list(
                                          "color" = "black",
                                          "font-weight" = "1000")
                                      )
                )

             shiny::observe({

                  if(is.null(dist_mod_df())) {
                      print(paste0("dist_mod_df is NULL"))
                       return(NULL)
                     } else {

                     #######################################################################
                     # ---- RENDER OBSERVED POINTS AND OBSERVED EDDI AND FORECAST PLOTS ----
                     #######################################################################
                     
                    #  # render observed resposne vs observed predictors points plot for selected district
                    #  output$observedPointPlot <- shiny::renderPlot({
                    #       # make a predictor vs fitted values plot
                    #     make_observed_plot2(
                    #       df       = model_data(),
                    #       pred_col = "predictor_val1",
                    #       yaxis    = predictor_long_str(),
                    #       ylim     = c(0, 1000)
                    #       )
                    #     })
                    #  
                    # # render observed resposne vs observed predictors points plot for selected district
                    #  output$observedEDDIPointPlot <- shiny::renderPlot({
                    #     # make a predictor vs fitted values plot
                    #     make_observed_plot2(
                    #       df       = model_data(),
                    #       pred_col = "predictor_val2",
                    #       yaxis    = predictor_long_str2(),
                    #       ylim     = c(-4, 4)
                    #       )
                    #     })
                       
                    #######################################################################
                    # -------------------- RENDER R-SQUARED VALUE BOX  --------------------
                    #######################################################################
                       
                    # # Render new R Squared value into value box
                    # output$rSquaredValueBox <- flexdashboard::renderValueBox(
                    #                 flexdashboard::valueBox(
                    #                   # value = paste0("R2: ", lm_out$r2),
                    #                   # value = paste0("R2: ", lm_data()$r2),
                    #                   value =  HTML(paste0("R",tags$sup("2"), ": " , round(lm_data()$r2, 2))),
                    #                   color = "warning",
                    #                   caption = " "
                    #                   )
                    #               )
                     }


               # print(paste0("----> current_district: ", model_dist_id()))

               })

             }
          })
#
# # # if "predict" button is clicked and there is a value in the newDataInput text box, make a prediction
shiny::observeEvent(input$newDataInputButton, {

        # start_district = model_dist_id()
        #
        # print(paste0("----> start_district: ", start_district))

        # if an input has been put into text box
        if (!is.null(input$newDataInput)) {

          print(paste0("input$newDataInput: ",input$newDataInput))

          # # make a prediction with new data from user input
          # pred <- make_prediction(
          #   model     = model_obj(),
          #   predictor = predictor_str(),
          #   val       = as.numeric(input$newDataInput)
          # )
          
          # make a prediction with new data from user input
          pred <- make_mlr_prediction(
            model = model_obj(),
            pred1 = predictor_str1(),
            pred2 = predictor_str2(),
            val1  = as.numeric(input$newDataInput),
            val2  = eddi_val()
          )
          
          ##########################################
          ##########################################

            # paste0("Call year ~ ", predictor_long_str(), " + ", predictor_long_str2())
            df_tbl <- dplyr::tibble(
              col1 = c(predictor_long_str(),
                       predictor_long_str2(),
                       "Summer Call (Apr-Sep)",
                       "Equation", 
                       "R²"
              ),
              col2 = c(
                round(as.numeric(input$newDataInput), 2),
                round(eddi_val(), 2), 
                round(pred$fitted, 0),
                # model_tbl$equation, 
                paste0("Call year ~ ", predictor_long_str(), " + ", predictor_long_str2()),
                round(lm_data()$r2, 2)
              ),
              row_name = c("—", "—", "—", "—", "—"),
              # row_name = c("- ", "- ", "- ", "- ", "- "),
              # row_name = c("*", "*", "*", "*", "*"),
              # row_name = c("|", "|", "|", "|", "|"),
              group = c("Predictor Variables", "Predictor Variables", "Response Variable", "Model Equation", "Performance")
            )

            
            model_table <- 
              df_tbl %>% 
              gt::gt(rowname_col = "row_name", groupname_col = "group") %>% 
              gt::tab_header(
                title = gt::md(paste0("**",
                                lm_lookup$district_name[lm_lookup$district == model_dist_id()],
                                "**"
                                  )
                                ),
                subtitle = gt::md(paste0("District: ", model_dist_id()))
                # subtitle = gt::md(paste0("**District: ", model_dist_id(), "**"))
                # title = md(paste0("**District: ", district_num, "**")),
                # subtitle = md(paste0(district_name))
              ) %>%
              gt::tab_style(
                style = list(
                  gt::cell_text(color = "white")  # Change the color to your preferred color
                ),
                locations = gt::cells_column_labels()
              ) %>%
              gt::tab_style(
                style = gt::cell_text(weight = "bold"),
                # locations = cells_column_labels(columns = "group")
                # locations = cells_body(columns = group)
                locations = gt::cells_row_groups()
              ) %>% 
              gt::tab_style( # highlight R squared value
                style = list(
                  gt::cell_fill(color = "gold", alpha = 0.8),
                  gt::cell_text(weight = "bold")
                  ),
                locations = gt::cells_body(rows = 5, columns = "col2") # column and row of cell to highlight
              ) %>% 
              gt::tab_style(
                style = list(  # highlight prediction value
                  gt::cell_fill(color = "#3EB489", alpha = 0.7),
                  gt::cell_text(weight = "bold")
                ),
                locations = gt::cells_body(rows = 3, columns = "col2") # column and row of cell to highlight
              ) %>% 
              gt::tab_style(
                style = gt::cell_fill(color = "indianred", alpha = 0.7), # highlight predictor variable values
                locations = gt::cells_body(rows = c(1, 2), columns = "col2") # column and row of cell to highlight
                ) %>% 
              gt::tab_options(
                table.font.size = 20
                )
            
          output$gtModelTable <- gt::render_gt({
            model_table
          })

          ##########################################
          ##########################################
          
          # # pred$predictor_long_name1 <- lm_l
          # # make a prediction with new data from user input
          # pred <- make_mlr_prediction(
          #   model     = model_obj(),
          #   pred1 = predictor_str1(),
          #   pred2 = predictor_str2(),
          #   val1       = as.numeric(input$newDataInput),
          #   val2  = eddi_val()
          # )


          print(paste0("prediction value: ", pred$fitted[1]))

          # # update the prediction value Value Box
          # output$predictionValueBox <- flexdashboard::renderValueBox(
          #                 flexdashboard::valueBox(
          #                   # value = paste0("R2: ", lm_out$r2),
          #                   value = paste0("Prediction: ", round(pred$fitted, 0)),
          #                   color = "success",
          #                   caption = " "
          #                   )
          #               )

          # # Update the plot based on the new prediction
          # output$predictorFitPlot <- shiny::renderPlot({
          # 
          #     make_new_predfit_plot(
          #       df = model_data(),
          #       # df = lm_out$model_data,
          #       pred_df = pred
          #     )
          #   
          # })
        
          # lm_list[["district_01"]]$model
          # predictor lm_list[["district_01"]]$model_data$predictor_long_name[1]
          #               pred <- make_prediction(
          #                    model     = lm_list[["district_01"]]$model,
          #             predictor = lm_list[["district_01"]]$model_data$predictor_long_name[1],
          #             val       = as.numeric(200))
          #           df = lm_list[["district_01"]]$model_data
          
          #########################################################################
          # ----- EDDI vs call year AND Observed Predictor vs call year PLOTS -----
          #########################################################################
          
          # # Update the plot based on the new prediction
          # output$observedPointPlot <- shiny::renderPlot({
          #   
          #     # make_new_observed_plot(
          #     #   df      = model_data(),
          #     #   pred_df = pred,
          #     #   yaxis   = NULL
          #     # )
          #   
          #   make_new_observed_plot2(
          #       df      = model_data(),
          #       pred_col = "predictor_val1",
          #       pred_df = pred,
          #       yaxis = predictor_long_str(),
          #       ylim = c(0, 1000)
          #   )
          # 
          # })
          # 
          # output$observedEDDIPointPlot <- shiny::renderPlot({
          #   
          #     # make_new_observed_plot(
          #     #   df      = model_data(),
          #     #   pred_df = pred,
          #     #   yaxis   = NULL
          #     # )
          #   
          #   make_new_observed_plot2(
          #       df      = model_data(),
          #       pred_col = "predictor_val2",
          #       pred_df = pred,
          #       yaxis = predictor_long_str2(),
          #       ylim = c(-4, 4)
          #   )
          # 
          # })
        }
      })
```

Column {data-width=250}
---------------------------------------------------------
###
```{r}
gt::gt_output("gtModelTable")
shinyBS::bsPopover(
  "gtModelTable",
  title     = "Interpretation of MLR",
    content   = paste0("<strong>Predictor Variables:</strong> these are the variables included in this districts MLR model.<br><br><strong>Prediction:</strong> This is the average summer call year that results from the two predictor variable values above. This means that water rights with appropriation dates after this predicted year are likely to be out of priority and receive no water.<br><br><strong>Model equation:</strong> This is the best fitting MLR model given the available predictor variables.<br><br><strong>Performance:</strong> The higher the R² value, the better the performance of the model."),
  placement = "left",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```
