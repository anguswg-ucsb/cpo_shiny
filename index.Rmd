---
title: "Colorado Water Rights"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    logo: www/lynker_logo_white_transparent.png
    css: www/custom.css
runtime: shiny
---

<style>

.navbar, [data-toggle=tab], .navbar-brand  {   background-color:#1c3a5d;   border-color:black;   color:white; }

</style>

```{r setup, include = FALSE}
# Shiny & Flexdashboard packages
library(shiny)
library(flexdashboard)

# Data manipulation
library(dplyr)
library(ggplot2)
library(gt)

# Mapping packages
library(leaflet)
library(leafem)

# geospatial and climate data
library(terra)
library(climateR)

# library(shinyjs)
library(shinyBS)

# Load function data_utils.R file
source('final_utils.R')
```

```{r context="server"}
# shinyjs::useShinyjs(rmd = TRUE)

# water rights data
water_rights <- readr::read_csv("detrended_all_data_final_v2.csv")

# linear regression lookup table
lm_lookup <- readr::read_csv("cpo_linear_regression_lookup_v2.csv")

# lm_lookup <- readr::read_csv("cpo_linear_regression_lookup.csv")

# subset of districts
# dists      <- sf::read_sf("water_districts_subset.gpkg")
dists <- sf::read_sf("water_districts_subset2.gpkg")

# catalog entry for getting EDDI data
cat <- readRDS("eddi_catalog2.rds") %>% 
  update_duration()
# cat <- readRDS("eddi_catalog.rds") %>% 
#   update_duration()

# get new EDDI 30 Day data when application loads
new_eddi <- eddi_from_catalog(
  catalog    = cat,
  aoi        = dplyr::mutate(dists, 
                             district = as.integer(district)),
  varname    = c("eddi30d", "eddi1y"),
  # varname    = "eddi30d",
  start_date = Sys.Date() - 365,
  end_date   = Sys.Date(),
  name_col   = "district",
  verbose    = FALSE
  )

# all_dists   <- sf::read_sf("water_districts_simple.geojson") %>%
#   dplyr::filter(DISTRICT  %in% c(1, 2, 3,  4, 5, 6,7, 8, 9, 23, 80, 64)) %>%
#   janitor::clean_names() %>%
#   dplyr::mutate(
#       district = ifelse(district < 10, paste0("0", district), as.character(district))
#     ) %>% 
#   sf::st_transform(4326) %>%
#   sf::st_cast("MULTIPOLYGON")
# sf::write_sf(all_dists, "water_districts_subset2.gpkg")

# average yeartype data
avg_yeartype <- readRDS("avg_weekly_calls_by_yeartype.rds") %>% 
  dplyr::mutate(
      district = ifelse(district < 10, paste0("0", district), as.character(district))
    )

# # districts of interest
# doi   = unique(lm_lookup$district)
# # districts for Linear Regression models on Page 2
# model_dists <-  dists
# model_dists <- 
#   dists %>% 
#   # dplyr::filter(DISTRICT %in% c("1", "5", "8", "64")) %>% 
#     dplyr::filter(DISTRICT %in% as.numeric(doi)) %>% 
#     dplyr::mutate(
#       DISTRICT = ifelse(DISTRICT < 10, paste0("0", DISTRICT), as.character(DISTRICT))
#     )

# data used to generate linear regression models
# mod_df <- readRDS("model_data.rds")
mod_df <- readRDS("mlr_model_data2.rds")
# mod_df$predictor_long_name
#  list of linear regression models and metrics
lm_list <- readRDS("mlr_model_list2.rds")
# lm_list <- readRDS("lin_reg_model_list2.rds")

# # make a list of linear regression models from a dataframe of districts with these columns: 
# #   "district", "resp_var", "resp_val", "predictor", and "predictor_val" columns
# lm_list <- make_lm_list(df = mod_df)
# saveRDS(lm_list, "data/lin_reg_model_list.rds")

# lm_list <- readRDS("data/lin_reg_model_list2.rds")
# lm_out <- make_lm(model_data = dist_mod_df())

# base leaflet map on page 1
output$baseMap       <- leaflet::renderLeaflet({ dist_basemap(shp = dists) })

# Model base leaflet map on page 2
output$modelBaseMap       <- leaflet::renderLeaflet({ model_basemap(shp = dists) })
```

```{r context="server"}
map_click <- shiny::reactive({
   input$baseMap_click
})
```

```{r context="server"}
# model_map_click <- shiny::reactive({
#    input$modelBaseMap_click
# })
```

```{r context="server"}
date_input <- shiny::reactive({
   input$dateInputVal
})
```

```{r context="server"}
dist_id <- shiny::reactive({
   # as.numeric(input$baseMap_shape_click$id)
   input$baseMap_shape_click$id
})

```

```{r context="server"}
sub_dist1 <- shiny::reactive({
  # subset to water district of interest
   # dists[dists$DISTRICT == dist_id(), ]
  
    # subset to water district of interest
    if(is.null(dist_id()) | dist_id() == " ") {
      
      return(NULL)
      
    } else {
         dists[dists$district == dist_id(), ]
    }
  
})
```

```{r, context = "server"}
model_dist_id <- shiny::reactive({
   input$districtInput
})

# # id of clicked district 
# model_dist_id <- shiny::reactive({
#    # as.numeric(input$baseMap_shape_click$id)
#   if(is.null(input$modelBaseMap_shape_click$id)) {
#     return(" ")
#   } else {
#     input$modelBaseMap_shape_click$id
#   }
#    # input$modelBaseMap_shape_click$id
# })
```

```{r context="server"}
# subset district polygon based on districtInput
sub_dist2 <- shiny::reactive({
  # subset to water district of interest
   # dists[dists$DISTRICT == model_dist_id(), ]

    # subset to water district of interest
    if(is.null(model_dist_id())) {

      return(NULL)

    } else {
      dists[dists$district == model_dist_id(), ]
    }

})

# dists[dists$DISTRICT == model_dist_id(), ]
# sub_dist2 <- shiny::reactive({
#   # subset to water district of interest
#    # dists[dists$DISTRICT == model_dist_id(), ]
#   
#     # subset to water district of interest
#     if(is.null(model_dist_id()) | model_dist_id() == " ") {
#       
#       return(NULL)
#       
#     } else {
#       dists[dists$DISTRICT == model_dist_id(), ]
#     }
#   
# })
# dists[dists$DISTRICT == model_dist_id(), ]
# dists[dists$DISTRICT == "01", ]
```

```{r context="server"}
# # list ID for lm_list of lin reg models
list_id <- shiny::reactive({

  # if(is.null(model_dist_id()) | model_dist_id() == " ") {
  if(is.null(model_dist_id())) {
    # return(" ")
    return(NULL)

  } else {

    paste0("district_", model_dist_id())

  }

})
```

```{r context="server"}

# # watch for changes in model_dist_id(), 
# shiny::observeEvent(model_dist_id(), {
#      # print(paste0("model_dist_id() CHANGED, RESETTING newDataInput AND newDataInputButton: ", model_dist_id()))
#      #
#      # print(paste0("newDataInput BEFORE reset: ", input$newDataInput))
#      # print(paste0("newDataInputButton BEFORE reset: ", input$newDataInputButton))
# 
#     # Whenever model_dist_id() changes, reset the input value and action button
#     shinyjs::reset("newDataInput")
#     shinyjs::reset("newDataInputButton")
# 
#     output$rSquaredValueBox <- NULL  # clear the R-squared value box
#     output$predictionValueBox <- NULL  # clear the predicted value value box
#     #
#     # print(paste0("newDataInput AFTER reset: ", input$newDataInput))
#     # print(paste0("newDataInputButton AFTER reset: ", input$newDataInputButton))
# })
```


```{r context="server"}
call_year_df <- shiny::reactive({
  avg_yeartype %>% 
    dplyr::filter(district == dist_id())
    # dplyr::filter(district == dist_id(), 
    #               year_type == input$radioYearTypeButtons)
})
```

```{r context="server"}
dist_mod_df <- shiny::reactive({
  mod_df %>% 
    dplyr::filter(district == model_dist_id())
    # dplyr::filter(district == dist_id(), 
    #               year_type == input$radioYearTypeButtons)
})
```

```{r context="server"}
eddi_df <- shiny::reactive({
  new_eddi %>% 
    dplyr::filter(district == model_dist_id())
    # new_eddi %>% 
    # dplyr::filter(district == "01")
    # dplyr::filter(district == dist_id(), 
    #               year_type == input$radioYearTypeButtons)
})
```

```{r context="server"}
# EDDI variable name for selected district
eddi_variable <- shiny::reactive({

  if(is.null(model_dist_id())) {
    return("")
  } else {
    return(
      dplyr::filter(
        lm_lookup,
        district == model_dist_id())$predictor_name2
      )
    
  }
  # dplyr::filter(lm_lookup, district == "01")$predictor_name2
  # new_eddi %>% 
  #   dplyr::filter(district == model_dist_id())
    # dplyr::filter(district == dist_id(), 
    #               year_type == input$radioYearTypeButtons)
})
```

```{r context="server"}
# EDDI value for selected district
eddi_val <- shiny::reactive({
    
  if(is.null(model_dist_id())) {
    return(0)
  } else {
    return(
      # dplyr::filter(
      #   new_eddi,
      #   district == model_dist_id())$may_eddi30d
      dplyr::filter(new_eddi, 
                    district == model_dist_id())[[eddi_variable()]]
      )
    
  }
  
  # dplyr::filter(new_eddi, district == "01")$may_eddi30d 
  # variable = "may_eddi30d"
  # dplyr::filter(new_eddi, district == "01")[[variable]]
  # dplyr::filter(new_eddi, 
  #               district == model_dist_id())[[eddi_variable()]]
  # new_eddi %>% 
  #   dplyr::filter(district == model_dist_id())
    # dplyr::filter(district == dist_id(), 
    #               year_type == input$radioYearTypeButtons)
})
```

```{r context="server"}
lm_data <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(list_id())) {
    return(NULL)
  } else {
    return(lm_list[[list_id()]])
  }
})
```

```{r context="server"}
model_data <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(lm_data())) {
    return(NULL)
  } else {
    return(lm_data()$model_data)
  }
})
```

```{r context="server"}
model_obj <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(lm_data())) {
    return(NULL)
  } else {
    return(lm_data()$model)
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_str1 <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor1[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_str2 <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor2[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_str <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_long_str <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor_long_name[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_long_str2 <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor_long_name2[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_label <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(predictor_long_str())) {
    
    return("Select a district to make a prediction..")
    
  } else {
    
    # return(paste0("Enter ", toupper(predictor_long_str()), " value..."))
    return(paste0("Enter ", predictor_long_str(), " value..."))
    
  }
})

# ifelse(
#   is.null(predictor_str()),
#   "Select a district to make a provide SWE/NRCS Forecast data...",
#   paste0("Enter ", predictor_str(), " value...")
#        )
```

Right-o-graph
==========================================

Inputs {.sidebar}
---------------------------------------------------------
```{r}
shiny::radioButtons(
  inputId  = "radioYearTypeButtons",
  label = "Water year type:",
  choices = c(
    "Dry"    = "Dry",
   "Average" = "Average",
   "Wet"     = "Wet"
   ),
  selected = "Average"
  )
```

<br>

- Add text describing how the average weekly call value is displayed and calculated in the bottom plot

- Add text describing wet, dry and average year types here

- ADD POPOVERS/TOOLTIPS TO EACH PANEL AS WELL

Column {data-width=500}
---------------------------------------------------------
### District
```{r}
flexdashboard::valueBoxOutput("districtValueBoxMap1")
shinyBS::bsPopover(
  "districtValueBoxMap1",
  title     = "",
  content   = "Water district",
  placement = "bottom",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
# {r context="server"}
# flexdashboard::valueBox(value = model_dist_id())
# ("primary", "info", "success", "warning", "danger")
output$districtValueBoxMap1 <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("District: "),
    color = "primary",
    caption = " "
    )
)

# Value box server
shiny::observeEvent(dist_id(), {
# shiny::observeEvent(event_trigger(), {
      # print("observer4")

      # Public Safety value box server
      output$districtValueBoxMap1 <- flexdashboard::renderValueBox(
        flexdashboard::valueBox(
          value = paste0("District: ", dist_id()),
          color = "primary",
          caption = " "
          )
        )

})
```

###
```{r}
shiny::plotOutput("callDatePlot")
shinyBS::bsPopover(
  "callDatePlot",
  title     = "Annual historic call dates by week",
  content   = "After clicking on a district on the map above, a lineplot showing the selected district's historic average call date (Y axis) for a given week of the year (X axis). The 3 lines each represent a different average value calculated for across all years for a given year type (dry, average, and wet). Year types were calculated by creating terciles from the annual total streamflow discharge volume at a representative USGS gage for each district.",
  placement = "left",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

Column {data-width=500}
---------------------------------------------------------
###
```{r}
# District leaflet map output
leaflet::leafletOutput("baseMap")
shinyBS::bsPopover(
  "baseMap",
  title     = "Colorado South Platte Water Districts",
  content   = "Click on a water district to view annual historical call dates for a given week",
  placement = "bottom",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# observeEvent(input$districtMapMLR_click, {
shiny::observeEvent(input$baseMap_shape_click, {
# shiny::observeEvent(input$baseMap_click, {
   if(is.null(dist_id())) {

     return(NULL)

   } else {
    
   # # if(!is.null(input$districtMapMLR_click)) {
   #    click <- input$districtMapMLR_click %>%
   #      data.frame() %>%
   #      dplyr::select(lat,lng)
      # print(click)

          pt <- sf::st_as_sf(
                    data.frame(
                      lat = map_click()$lat,
                      lng = map_click()$lng
                      ),
                    coords = c("lng", "lat"),
                    crs = 4326
                    )
          # 39.7792 -105.7214
          # 40.66392 -105.4837
          # 40.69808 -105.6
          # pt <- sf::st_as_sf(
          #           data.frame(
          #             lat = "39.978",
          #             lng =  "-105.6"
          #             ),
          #           coords = c("lng", "lat"),
          #           crs = 4326
          #           )

          print(paste0("Subsetting mainstems to HUC4: ",  dist_id()))

          print("Subsetting WDIDs to district area...")
# 
#           # subset to water district of interest
#           sub_dist <- dists[dists$DISTRICT == dist_id(), ]


          # area_nhd <- nhdplusTools::get_nhdplus(
          #   AOI         = sub_dist,
          #   realization = c("flowline"),
          #   streamorder = 5
          #   )

          # nhdplusTools::navigate_network(
          #   start = pt,
          #
          # )


          # sub_pts  <- wr_pts[wr_pts$water_district == dist_id(), ]
          # sub_dist <- dists[dists$DISTRICT == as.numeric("06"), ]
          # sub_pts  <- wr_pts[wr_pts$water_district == as.numeric("06"), ]

          print("Updating leaflet map...")

          # dynamically alter leaflet map
          leaflet::leafletProxy("baseMap") %>%
              leaflet::clearMarkers() %>%
              leaflet::clearShapes() %>%
              leaflet::clearGroup(c("subdist1")) %>%
                # leaflet::removeShape(layerId = levelpathi) %>%
                leaflet::addPolygons(
                      data         = dists,
                      fillColor    = 'white',
                      # fillColor = 'grey',
                      # fillColor = ~pal_fact(BASIN),
                      fillOpacity  = 0.7,
                      col          = "black",
                      opacity      = 1,
                      weight       = 2.5,
                      label        = ~paste0("District: ", district),
                      layerId      = ~district,
                      labelOptions = leaflet::labelOptions(
                                          noHide = F,
                                          style  = list(
                                            "color" = "black",
                                            "font-weight" = "1000")
                                        )
                  ) %>%
                leaflet::addPolygons(
                    # data         = sub_dist,
                    data = sub_dist1(),
                    fillColor    = '#3EB489',
                    # fillColor = 'grey',
                    # fillColor = ~pal_fact(BASIN),
                    fillOpacity  = 0.5,
                    col          = "black",
                    opacity      = 1,
                    weight       = 3,
                    group        = "subdist1",
                    label        = ~paste0("District: ", district),
                    layerId      = ~district,
                    labelOptions = leaflet::labelOptions(
                                        noHide = F,
                                        style  = list(
                                          "color" = "black",
                                          "font-weight" = "1000")
                                      )
                )
            # leaflet::addPolylines(
            #   data = area_nhd,
            #   color = "navy",
            #   opacity = 0.9,
            #   stroke = TRUE
            # )
              # leaflet::addCircleMarkers(
              #         data        = sub_pts()[sub_pts()$wdid == input$selectWDID, ],
              #         radius      = 10,
              #         stroke      = FALSE,
              #         color       = "red",
              #         opacity     = 1,
              #         fillColor   = "red",
              #         fillOpacity = 0.7
              #         )
            # leaflet::addCircleMarkers(
            #   data = sub_pts$
            #
            # )

             shiny::observe({

                  if(is.null(dist_id())) {

                       return(NULL)
             #
                     } else {
            
                     # render call date over time plot
                     output$callDatePlot <- shiny::renderPlot({
                       
                        make_avg_yeartype_rightograph_plot(
                          df    = call_year_df(),
                          type  = input$radioYearTypeButtons
                          )

                        })
                     
                       }
               })
             }
          })
```

Regression models 
==========================================

Inputs {.sidebar}
---------------------------------------------------------
```{r, context = "server"}
# ifelse(
#   is.null(predictor_str()),
#   "Select a district to make a provide SWE/NRCS Forecast data...",
#   paste0("Enter ", predictor_str(), " value...")
#        )
# shiny::numericInput(
#   inputId = "districtInput",
#                   label   = "Select a district",
#                   value = NULL
#                   )
# shiny::selectInput(
#    inputId = "districtInput",
#    label   = "Select a district",
#    choices = c(
#               # "" = NA,
#               "1" = "01", 
#               "2" = "02", 
#               "3" = "03", 
#               "4" = "04", 
#               "5" = "05", 
#               "6" = "06",
#               "7" = "07",
#               "8" = "08",
#               "9" = "09",
#               "23" = "23",
#               "64" = "64",
#               "80" = "80"
#               ),
#    selected = NULL
#    )
# shiny::selectInput(
#    inputId = "districtInput",
#    label   = "Select a district",
#    choices = c(
#               # "" = NA,
#               "1" = "01", 
#               "2" = "02", 
#               "3" = "03", 
#               "4" = "04", 
#               "5" = "05", 
#               "6" = "06",
#               "7" = "07",
#               "8" = "08",
#               "9" = "09",
#               "23" = "23",
#               "64" = "64",
#               "80" = "80"
#               ),
#    selected  = FALSE,
#    multiple  = FALSE, 
#    selectize = FALSE,
#    size      = 12
#    )

shiny::selectizeInput(
  inputId = "districtInput",
  label   = "Select a district",
  choices = c(
                # "" = NA,
                "1" = "01", 
                "2" = "02", 
                "3" = "03", 
                "4" = "04", 
                "5" = "05", 
                "6" = "06",
                "7" = "07",
                "8" = "08",
                "9" = "09",
                "23" = "23",
                "64" = "64",
                "80" = "80"
                ),
  multiple = TRUE, 
  options = list(maxItems = 1)
  ) 

shiny::textInput(inputId = "newDataInput", 
                 # label = predictor_label(),
                 label   = "...",
                 # label   = ifelse(
                 #              is.null(predictor_str()), 
                 #              "Select a district to make a provide SWE/NRCS Forecast data...", 
                 #              paste0("Enter ", predictor_str(), " value...")
                 #                   ),
                 value   = NULL
                 )

shiny::actionButton("newDataInputButton",
                    label = "Predict")

shiny::observeEvent(predictor_label(), {
    shiny::updateTextInput(session, "newDataInput", label = predictor_label())
  })
```

<br>

- ADD TEXT DESCRIBING MODELING PROCESS AND SPECIFIC VARIABLES USED

- Predictor vs Fitted Values is a plot showing the values used to predict average call year (X axis) and the fitted average call year values (Y axis)

- After clicking on a district, you will be shown the R squared value in the middle value box on the top row, and if you type a SWE or NRCS Forecast value into the input box above and press the "Predict" button, a predicted average call year value will be shown in the top right "Predicted" value box

- ADD POPOVERS/TOOLTIPS TO EACH PANEL AS WELL

Column {data-width=500}
---------------------------------------------------------
### District
```{r}
flexdashboard::valueBoxOutput("districtValueBoxMap2")
shinyBS::bsPopover(
  "districtValueBoxMap2",
  title     = "",
  content   = "Water district",
  placement = "bottom",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
# {r context="server"}
# flexdashboard::valueBox(value = model_dist_id())
# ("primary", "info", "success", "warning", "danger")
output$districtValueBoxMap2 <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("District: "),
    color = "primary",
    caption = " "
    )
)

# Value box server
shiny::observeEvent(model_dist_id(), {
# shiny::observeEvent(event_trigger(), {
      # print("observer4")

      # Public Safety value box server
      output$districtValueBoxMap2 <- flexdashboard::renderValueBox(
        flexdashboard::valueBox(
          value = paste0("District: ", model_dist_id()),
          color = "primary",
          caption = " "
          )
        )

})
```

### Model Map
```{r}
leaflet::leafletOutput("modelBaseMap")
shinyBS::bsPopover(
  "modelBaseMap",
  title     = "Colorado South Platte Water Districts",
  content   = "Use the selection drop down in the left panel to select and highlight a water district on the map",
  placement = "bottom",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
# # # Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# # # observeEvent(input$districtMapMLR_click, {
# # shiny::observeEvent(input$modelBaseMap_shape_click, {
shiny::observeEvent(model_dist_id(), {
   if(is.null(model_dist_id())) {

     return(NULL)

   } else {

          # pt <- sf::st_as_sf(
          #           data.frame(
          #             lat = model_map_click()$lat,
          #             lng = model_map_click()$lng
          #             ),
          #           coords = c("lng", "lat"),
          #           crs = 4326
          #           )
          # # 39.7792 -105.7214
          # # 40.66392 -105.4837
          # # 40.69808 -105.6
          #  print(paste0("Map 2 latitude ---> ", model_map_click()$lat))
          #  print(paste0("Map 2 longitude ---> ", model_map_click()$lng))
          # # print(paste0("Subsetting mainstems to HUC4: ",  model_dist_id()))
          # print(paste0("Page 2 district selection ---> ", model_dist_id()))
          # 
          # print(paste0("Highlighting district ", model_dist_id(), " based on districtInput change..."))

          # # subset to water district of interest
          # sub_dist2 <- dists[dists$DISTRICT == model_dist_id(), ]
     
          print(paste0("===== model_dist_id: ", model_dist_id(), " ====="))
     
          print(paste0("===== predictor_str(): ", predictor_str(), " ====="))
          print(paste0("===== predictor_label(): ", predictor_label(), " ====="))
          
          print(paste0("===== predictor_str2(): ", predictor_str2(), " ====="))
          print(paste0("===== predictor_long_str2(): ", predictor_long_str2(), " ====="))
          
          print(paste0("===== eddi_variable(): ", eddi_variable(), " ====="))
          print(paste0("===== eddi_val(): ", eddi_val(), " ====="))
          
          print("Updating leaflet map...")

          # dynamically alter leaflet map
          leaflet::leafletProxy("modelBaseMap") %>%
              leaflet::clearMarkers() %>%
              leaflet::clearShapes() %>%
              leaflet::clearGroup(c("subdist2")) %>%
                # leaflet::removeShape(layerId = levelpathi) %>%
                leaflet::addPolygons(
                      data         = dists,
                      fillColor    = 'white',
                      # fillColor = 'grey',
                      # fillColor = ~pal_fact(BASIN),
                      fillOpacity  = 0.7,
                      col          = "black",
                      opacity      = 1,
                      weight       = 2.5,
                      label        = ~paste0("District: ", district),
                      layerId      = ~district,
                      labelOptions = leaflet::labelOptions(
                                          noHide = F,
                                          style  = list(
                                            "color" = "black",
                                            "font-weight" = "1000")
                                        )
                  ) %>%
                leaflet::addPolygons(
                      # data         = sub_dist2,
                    data         = sub_dist2(),
                    fillColor    = '#3EB489',
                    # fillColor = 'grey',
                    # fillColor = ~pal_fact(BASIN),
                    fillOpacity  = 0.5,
                    col          = "black",
                    opacity      = 1,
                    weight       = 3,
                    group        = "subdist2",
                    label        = ~paste0("district: ", district),
                    layerId      = ~district,
                    labelOptions = leaflet::labelOptions(
                                        noHide = F,
                                        style  = list(
                                          "color" = "black",
                                          "font-weight" = "1000")
                                      )
                )

              # print(paste0("- list_id(): ", list_id()))
              # print(paste0("- class(model_obj()): ",
              #              class(model_obj()))
              #       )
              # 
              #  print(paste0("- class(model_data()): ",
              #              class(model_data()))
              #        )

             shiny::observe({

                  if(is.null(dist_mod_df())) {
                      print(paste0("dist_mod_df is NULL"))
                       return(NULL)
                     } else {

                     #######################################################################
                     # ---- RENDER OBSERVED POINTS AND OBSERVED EDDI AND FORECAST PLOTS ----
                     #######################################################################
                     
                    #  # render observed resposne vs observed predictors points plot for selected district
                    #  output$observedPointPlot <- shiny::renderPlot({
                    #       # make a predictor vs fitted values plot
                    #     make_observed_plot2(
                    #       df       = model_data(),
                    #       pred_col = "predictor_val1",
                    #       yaxis    = predictor_long_str(),
                    #       ylim     = c(0, 1000)
                    #       )
                    #     })
                    #  
                    # # render observed resposne vs observed predictors points plot for selected district
                    #  output$observedEDDIPointPlot <- shiny::renderPlot({
                    #     # make a predictor vs fitted values plot
                    #     make_observed_plot2(
                    #       df       = model_data(),
                    #       pred_col = "predictor_val2",
                    #       yaxis    = predictor_long_str2(),
                    #       ylim     = c(-4, 4)
                    #       )
                    #     })

                    # Render new R Squared value into value box
                    output$rSquaredValueBox <- flexdashboard::renderValueBox(
                                    flexdashboard::valueBox(
                                      # value = paste0("R2: ", lm_out$r2),
                                      # value = paste0("R2: ", lm_data()$r2),
                                      value =  HTML(paste0("R",tags$sup("2"), ": " , round(lm_data()$r2, 2))),
                                      color = "warning",
                                      caption = " "
                                      )
                                  )
                     }


               # print(paste0("----> current_district: ", model_dist_id()))

               })

             }
          })
#
# # # if "predict" button is clicked and there is a value in the newDataInput text box, make a prediction
shiny::observeEvent(input$newDataInputButton, {

        # start_district = model_dist_id()
        #
        # print(paste0("----> start_district: ", start_district))

        # if an input has been put into text box
        if (!is.null(input$newDataInput)) {

          print(paste0("input$newDataInput: ",input$newDataInput))

          # # make a prediction with new data from user input
          # pred <- make_prediction(
          #   model     = model_obj(),
          #   predictor = predictor_str(),
          #   val       = as.numeric(input$newDataInput)
          # )
          
          # make a prediction with new data from user input
          pred <- make_mlr_prediction(
            model = model_obj(),
            pred1 = predictor_str1(),
            pred2 = predictor_str2(),
            val1  = as.numeric(input$newDataInput),
            val2  = eddi_val()
          )
          # pred$fitted
          ##########################################
          ##########################################
          
            # model_tbl <- 
            #   dplyr::bind_cols(
            #     dplyr::filter(lm_lookup, district == model_dist_id()),
            #     pred
            #   )
            # paste0("Call year ~ ", predictor_long_str(), " + ", predictor_long_str2())
            df_tbl <- dplyr::tibble(
              col1 = c(predictor_long_str(),
                       predictor_long_str2(),
                       "Prediction",
                       "Equation", 
                       "R²"
              ),
              col2 = c(
                round(as.numeric(input$newDataInput), 2),
                round(eddi_val(), 2), 
                round(pred$fitted, 0),
                # model_tbl$equation, 
                paste0("Call year ~ ", predictor_long_str(), " + ", predictor_long_str2()),
                round(lm_data()$r2, 2)
              ),
              row_name = c("-", "-", "-", "-", "-"),
              group = c("Predictor Variables", "Predictor Variables", "Prediction", "Model Equation", "Performance")
            )
          
            
            model_table <- 
              df_tbl %>% 
              gt::gt(rowname_col = "row_name", groupname_col = "group") %>% 
              gt::tab_header(
                # title = md("**My Table Title**")
                title = gt::md(paste0(
                                lm_lookup$district_name[lm_lookup$district == model_dist_id()]
                                  )
                                ),
                subtitle = gt::md(paste0("**District: ", model_dist_id(), "**"))
                # title = md(paste0("**District: ", district_num, "**")),
                # subtitle = md(paste0(district_name))
              ) %>%
              gt::tab_style(
                style = list(
                  gt::cell_text(color = "white")  # Change the color to your preferred color
                ),
                locations = gt::cells_column_labels()
              ) %>%
              gt::tab_style(
                style = gt::cell_text(weight = "bold"),
                # locations = cells_column_labels(columns = "group")
                # locations = cells_body(columns = group)
                locations = gt::cells_row_groups()
              )

          output$gtModelTable <- gt::render_gt({
            model_table
          })

          ##########################################
          ##########################################
          
          # pred$predictor_long_name1 <- lm_l
          # make a prediction with new data from user input
          pred <- make_mlr_prediction(
            model     = model_obj(),
            pred1 = predictor_str1(),
            pred2 = predictor_str2(),
            val1       = as.numeric(input$newDataInput),
            val2  = eddi_val()
          )


          print(paste0("prediction value: ", pred$fitted[1]))

          # update the prediction value Value Box
          output$predictionValueBox <- flexdashboard::renderValueBox(
                          flexdashboard::valueBox(
                            # value = paste0("R2: ", lm_out$r2),
                            value = paste0("Prediction: ", round(pred$fitted, 0)),
                            color = "success",
                            caption = " "
                            )
                        )

          # # Update the plot based on the new prediction
          # output$predictorFitPlot <- shiny::renderPlot({
          # 
          #     make_new_predfit_plot(
          #       df = model_data(),
          #       # df = lm_out$model_data,
          #       pred_df = pred
          #     )
          #   
          # })
        
          # lm_list[["district_01"]]$model
          # predictor lm_list[["district_01"]]$model_data$predictor_long_name[1]
          #               pred <- make_prediction(
          #                    model     = lm_list[["district_01"]]$model,
          #             predictor = lm_list[["district_01"]]$model_data$predictor_long_name[1],
          #             val       = as.numeric(200))
          #           df = lm_list[["district_01"]]$model_data
          
          #########################################################################
          # ----- EDDI vs call year AND Observed Predictor vs call year PLOTS -----
          #########################################################################
          
          # # Update the plot based on the new prediction
          # output$observedPointPlot <- shiny::renderPlot({
          #   
          #     # make_new_observed_plot(
          #     #   df      = model_data(),
          #     #   pred_df = pred,
          #     #   yaxis   = NULL
          #     # )
          #   
          #   make_new_observed_plot2(
          #       df      = model_data(),
          #       pred_col = "predictor_val1",
          #       pred_df = pred,
          #       yaxis = predictor_long_str(),
          #       ylim = c(0, 1000)
          #   )
          # 
          # })
          # 
          # output$observedEDDIPointPlot <- shiny::renderPlot({
          #   
          #     # make_new_observed_plot(
          #     #   df      = model_data(),
          #     #   pred_df = pred,
          #     #   yaxis   = NULL
          #     # )
          #   
          #   make_new_observed_plot2(
          #       df      = model_data(),
          #       pred_col = "predictor_val2",
          #       pred_df = pred,
          #       yaxis = predictor_long_str2(),
          #       ylim = c(-4, 4)
          #   )
          # 
          # })
        }
      })
```

Column {data-width=250}
---------------------------------------------------------
###
```{r}
# # output prediction value box UI
gt::gt_output("gtModelTable")
# flexdashboard::valueBoxOutput("predictionValueBox")
```

###
```{r}
# # output prediction value box UI
flexdashboard::valueBoxOutput("eddiValueBox")
```

```{r context="server"}
# # Render the prediction value Value Box
output$eddiValueBox <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    # value = paste0("EDDI: ", round(eddi_val(), 2)),
        value = paste0("Predictor: ", round(eddi_val(), 2)),
    color = "danger",
    caption = predictor_long_str2()
    )
)
```

###
```{r}
# # output prediction value box UI
flexdashboard::valueBoxOutput("primaryPredictorValueBox")
```

```{r context="server"}
# # Render the prediction value Value Box
output$primaryPredictorValueBox <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("Predictor: ", round(as.numeric(input$newDataInput), 2)),
    color = "danger",
    caption = predictor_long_str()
    )
)
```

###
```{r}
flexdashboard::valueBoxOutput("rSquaredValueBox")
shinyBS::bsPopover(
  "rSquaredValueBox",
  title     = HTML(paste0("R",tags$sup("2"))),
  content   = "R-squared is a statistical measure that represents the proportion of the variance for a dependent variable that’s explained by an independent variable in a regression model.",
  placement = "bottom",
  options   = list(container = "body")
  )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
# # flexdashboard::valueBox(value = model_dist_id())
# 
output$rSquaredValueBox <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    # value = paste0("R2: "),
    value =  HTML(paste0("R",tags$sup("2"), ": ")),
    color = "warning",
    caption = " "
    )
)
```

###
```{r}
# # output prediction value box UI
flexdashboard::valueBoxOutput("predictionValueBox")
```

```{r context="server"}
# # Render the prediction value Value Box
output$predictionValueBox <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("Prediction: "),
    color = "success",
    caption = " "
    )
)
```

<!-- Row -->
<!-- --------------------------------------------------------- -->
<!-- ### Observed EDDI -->
<!-- ```{r} -->
<!-- # shiny::plotOutput("observedEDDIPointPlot") -->
<!-- # shinyBS::bsPopover( -->
<!-- #   "observedPointPlot", -->
<!-- #   title     = "Observed call year vs. Observed May 1 EDDI 30 day", -->
<!-- #   content   = "", -->
<!-- #   placement = "top", -->
<!-- #   options   = list(container = "body") -->
<!-- #   ) -->
<!-- # tags$style(HTML(" -->
<!-- #                 .tooltip > .tooltip-inner { -->
<!-- #                 width: 400px; -->
<!-- #                 color: black; -->
<!-- #                 background-color: white; -->
<!-- #                 } -->
<!-- #                 ")) -->
<!-- ``` -->

<!-- ### Observed response vs. Observed predictors -->
<!-- ```{r} -->
<!-- # shiny::plotOutput("observedPointPlot") -->
<!-- # shinyBS::bsPopover( -->
<!-- #   "observedPointPlot", -->
<!-- #   title     = "Observed call year vs. Observed predictor variables", -->
<!-- #   content   = "The plot has observed average annual call year on the X axis and the observed predictor variable values for a given district. Providing predictor values to the input box on the left panel and pressing the predict button will generate a predicted average call year value based on the predictor value given. A red dot will be added to the scatter plot indicating the value The models explanitory power is explained through the R2 value displayed on the plot and in the value box above the map.", -->
<!-- #   placement = "top", -->
<!-- #   options   = list(container = "body") -->
<!-- #   ) -->
<!-- # tags$style(HTML(" -->
<!-- #                 .tooltip > .tooltip-inner { -->
<!-- #                 width: 400px; -->
<!-- #                 color: black; -->
<!-- #                 background-color: white; -->
<!-- #                 } -->
<!-- #                 ")) -->
<!-- ``` -->

<!-- ### Predictor vs. Fitted values -->
<!-- ```{r} -->
<!-- shiny::plotOutput("predictorFitPlot") -->
<!-- ``` -->

<!-- ### Observed vs. Predicted -->
<!-- ```{r} -->
<!-- shiny::plotOutput("fittedPointPlot") -->
<!-- ``` -->