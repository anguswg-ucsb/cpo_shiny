---
title: "Colorado Water Rights"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
runtime: shiny
---

```{r setup, include = FALSE}
# Shiny & Flexdashboard packages
library(shiny)
library(flexdashboard)

# Data manipulation
# library(tidyr)
# library(dplyr)
library(dplyr)
library(ggplot2)
library(DT)

# Mapping packages
library(leaflet)
library(leafem)
# library(shinyjs)

# water data
# library(nhdplusTools)
# library(cdssr)

# Load function data_utils.R file
source('final_utils.R')
# shinyjs::useShinyjs()
# useShinyjs()
```

```{r context="server"}

# shinyjs::useShinyjs(rmd = TRUE)
# water rights net amounts spatial data

# wrs <- readr::read_csv("data/detrended_all_data_final.csv")
# raw <- readr::read_csv("/Users/anguswatters/Downloads/cdss_raw_daily_call_data_combined.csv")
# weekly_calls <- aggreg_weekly_district(raw)
# avg_yeartype <-  aggreg_by_year_type(weekly_calls) %>%
# dplyr::mutate(
# year_type = dplyr::case_when(
#                 year_type == "average" ~ "Average",
#                 year_type == "wet" ~ "Wet",
#                 year_type == "dry" ~ "Dry"
#               )
# )
# saveRDS(weekly_calls, "data/weekly_calls_by_district.rds")
# saveRDS(avg_yeartype, "data/weekly_calls_by_yeartype.rds")
# dists      <- sf::read_sf("data/water_districts_simple.geojson") 
# dists2 <- 
#   dists %>% 
#   dplyr::filter(DISTRICT %in% c(unique(avg_yeartype$district)))
# sf::write_sf(dists2, "data/water_districts_subset.gpkg")  

# # weekly calls data
# weekly_calls <- readRDS("data/weekly_calls_by_district.rds")

# # # average year type average priority date 
# avg_yeartype <- readRDS("data/weekly_calls_by_yeartype.rds")

# # subset of districts
# dists      <- sf::read_sf("data/water_districts_subset.gpkg")
# weekly_calls <- readr::read_csv("data/weekly_calls_by_district.rds")
# year_types <- readr::read_csv("/Users/anguswatters/Downloads/water_district_yeartype.csv")
# avg_yeartype$year_type %>% unique()
# average year type average priority date 
# avg_yeartype <- 
#   weekly_calls %>% 
#   dplyr::select(-year_type) %>% 
#   dplyr::mutate(
#     district = ifelse(district < 10, paste0("0", district), as.character(district))
#     ) %>% 
#   dplyr::left_join(
#     dplyr::mutate(
#       year_types,
#       district = ifelse(district < 10, paste0("0", district), as.character(district)),
#       year     = as.character(year)
#     ),
#     by = c("district", "year")
#   ) %>% 
#   dplyr::rename(year_type = type) %>% 
#   na.omit() %>% 
#   aggreg_by_year_type() %>% 
#   dplyr::mutate(
#     year_type = dplyr::case_when(
#                     year_type == "average" ~ "Average",
#                     year_type == "wet" ~ "Wet",
#                     year_type == "dry" ~ "Dry"
#                   )
#     ) %>% 
#   dplyr::mutate(district = as.numeric(district))
# 
# saveRDS(avg_yeartype, "data/avg_weekly_calls_by_yeartype.rds")

# # weekly calls data
# weekly_calls <- readRDS("data/weekly_calls_by_district.rds")

# # # average year type average priority date 
# avg_yeartype <- readRDS("data/weekly_calls_by_yeartype.rds")

water_rights <- readr::read_csv("detrended_all_data_final.csv")

# linear regression lookup table
lm_lookup <- readr::read_csv("cpo_linear_regression_lookup.csv")

# subset of districts
dists      <- sf::read_sf("water_districts_subset.gpkg")

avg_yeartype <- readRDS("avg_weekly_calls_by_yeartype.rds")

# districts of interest
doi   = unique(lm_lookup$district)

# districts for Linear Regression models on Page 2
model_dists <- 
  dists %>% 
  # dplyr::filter(DISTRICT %in% c("1", "5", "8", "64")) %>% 
    dplyr::filter(DISTRICT %in% as.numeric(doi)) %>% 
    dplyr::mutate(
      DISTRICT = ifelse(DISTRICT < 10, paste0("0", DISTRICT), as.character(DISTRICT))
    )

# data used to generate linear regression models
mod_df <- readRDS("model_data.rds")

#  list of linear regression models and metrics
lm_list <- readRDS("lin_reg_model_list2.rds")

# # make a list of linear regression models from a dataframe of districts with these columns: 
# #   "district", "resp_var", "resp_val", "predictor", and "predictor_val" columns
# lm_list <- make_lm_list(df = mod_df)
# saveRDS(lm_list, "data/lin_reg_model_list.rds")

# lm_list <- readRDS("data/lin_reg_model_list2.rds")

# lm_out <- make_lm(model_data = dist_mod_df())

# base leaflet map on page 1
output$baseMap       <- leaflet::renderLeaflet({ dist_basemap(shp = dists) })

# Model base leaflet map on page 2
output$modelBaseMap       <- leaflet::renderLeaflet({ model_basemap(shp = model_dists) })
```

```{r context="server"}
map_click <- shiny::reactive({
   input$baseMap_click
})
```

```{r context="server"}
model_map_click <- shiny::reactive({
   input$modelBaseMap_click
})
```

```{r context="server"}
date_input <- shiny::reactive({
   input$dateInputVal
})
```

```{r context="server"}
dist_id <- shiny::reactive({
   # as.numeric(input$baseMap_shape_click$id)
   input$baseMap_shape_click$id
})

```

```{r context="server"}
sub_dist1 <- shiny::reactive({
  # subset to water district of interest
   # dists[dists$DISTRICT == dist_id(), ]
  
    # subset to water district of interest
    if(is.null(dist_id()) | dist_id() == " ") {
      
      return(NULL)
      
    } else {
         dists[dists$DISTRICT == dist_id(), ]
    }
  
})
```

```{r context="server"}
sub_dist2 <- shiny::reactive({
  # subset to water district of interest
   # model_dists[model_dists$DISTRICT == model_dist_id(), ]
  
    # subset to water district of interest
    if(is.null(model_dist_id()) | model_dist_id() == " ") {
      
      return(NULL)
      
    } else {
      model_dists[model_dists$DISTRICT == model_dist_id(), ]
    }
  
})
```

```{r context="server"}
# id of clicked district 
model_dist_id <- shiny::reactive({
   # as.numeric(input$baseMap_shape_click$id)
  if(is.null(input$modelBaseMap_shape_click$id)) {
    return(" ")
  } else {
    input$modelBaseMap_shape_click$id
  }
   # input$modelBaseMap_shape_click$id
})
```

```{r context="server"}
# list ID for lm_list of lin reg models
list_id <- shiny::reactive({
  
  if(model_dist_id() == " ") {
      
    # return(" ")
    return(NULL)
      
  } else {
   
    paste0("district_", model_dist_id())
    
  }
  
})
```

```{r context="server"}

# # watch for changes in model_dist_id(), 
# shiny::observeEvent(model_dist_id(), {
#      # print(paste0("model_dist_id() CHANGED, RESETTING newDataInput AND newDataInputButton: ", model_dist_id()))
#      #
#      # print(paste0("newDataInput BEFORE reset: ", input$newDataInput))
#      # print(paste0("newDataInputButton BEFORE reset: ", input$newDataInputButton))
# 
#     # Whenever model_dist_id() changes, reset the input value and action button
#     shinyjs::reset("newDataInput")
#     shinyjs::reset("newDataInputButton")
# 
#     output$rSquaredValueBox <- NULL  # clear the R-squared value box
#     output$predictionValueBox <- NULL  # clear the predicted value value box
#     #
#     # print(paste0("newDataInput AFTER reset: ", input$newDataInput))
#     # print(paste0("newDataInputButton AFTER reset: ", input$newDataInputButton))
# })
```


```{r context="server"}
call_year_df <- shiny::reactive({
  avg_yeartype %>% 
    dplyr::filter(district == dist_id())
    # dplyr::filter(district == dist_id(), 
    #               year_type == input$radioYearTypeButtons)
})
```

```{r context="server"}
dist_mod_df <- shiny::reactive({
  mod_df %>% 
    dplyr::filter(district == model_dist_id())
    # dplyr::filter(district == dist_id(), 
    #               year_type == input$radioYearTypeButtons)
})
```

```{r context="server"}
lm_data <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(list_id())) {
    return(NULL)
  } else {
    return(lm_list[[list_id()]])
  }
})
```

```{r context="server"}
model_data <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(lm_data())) {
    return(NULL)
  } else {
    return(lm_data()$model_data)
  }
})
```

```{r context="server"}
model_obj <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(lm_data())) {
    return(NULL)
  } else {
    return(lm_data()$model)
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_str <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_long_str <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(model_data())) {
    
    return(NULL)
    
  } else {
    
    return(model_data()$predictor_long_name[1])
  }
})
```

```{r context="server"}
# string containing the predictor for the given district
predictor_label <- shiny::reactive({
  
  # if list_id() is NULL, return NULL, otherwise, get the given district lm_list element
  if(is.null(predictor_long_str())) {
    
    return("Select a district to make a prediction..")
    
  } else {
    
    return(paste0("Enter ", toupper(predictor_long_str()), " value..."))
    
  }
})

# ifelse(
#   is.null(predictor_str()),
#   "Select a district to make a provide SWE/NRCS Forecast data...",
#   paste0("Enter ", predictor_str(), " value...")
#        )
```

Right-o-graph
==========================================

Inputs {.sidebar}
---------------------------------------------------------
```{r}
shiny::radioButtons(
  inputId  = "radioYearTypeButtons",
  label = "Water year type:",
  choices = c(
    "Dry"    = "Dry",
   "Average" = "Average",
   "Wet"     = "Wet"
   ),
  selected = "Average"
  )
```

<br>

- Add text describing how the average weekly call value is displayed and calculated in the bottom plot

- Add text describing wet, dry and average year types here

- ADD POPOVERS/TOOLTIPS TO EACH PANEL AS WELL

Row
---------------------------------------------------------
### Map 1
```{r}
leaflet::leafletOutput("baseMap")
```

```{r context="server"}
# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# observeEvent(input$districtMapMLR_click, {
shiny::observeEvent(input$baseMap_shape_click, {
# shiny::observeEvent(input$baseMap_click, {
   if(is.null(dist_id())) {

     return(NULL)

   } else {
    
   # # if(!is.null(input$districtMapMLR_click)) {
   #    click <- input$districtMapMLR_click %>%
   #      data.frame() %>%
   #      dplyr::select(lat,lng)
      # print(click)

          pt <- sf::st_as_sf(
                    data.frame(
                      lat = map_click()$lat,
                      lng = map_click()$lng
                      ),
                    coords = c("lng", "lat"),
                    crs = 4326
                    )
          # 39.7792 -105.7214
          # 40.66392 -105.4837
          # 40.69808 -105.6
          # pt <- sf::st_as_sf(
          #           data.frame(
          #             lat = "39.978",
          #             lng =  "-105.6"
          #             ),
          #           coords = c("lng", "lat"),
          #           crs = 4326
          #           )

          print(paste0("Subsetting mainstems to HUC4: ",  dist_id()))

          print("Subsetting WDIDs to district area...")
# 
#           # subset to water district of interest
#           sub_dist <- dists[dists$DISTRICT == dist_id(), ]


          # area_nhd <- nhdplusTools::get_nhdplus(
          #   AOI         = sub_dist,
          #   realization = c("flowline"),
          #   streamorder = 5
          #   )

          # nhdplusTools::navigate_network(
          #   start = pt,
          #
          # )


          # sub_pts  <- wr_pts[wr_pts$water_district == dist_id(), ]
          # sub_dist <- dists[dists$DISTRICT == as.numeric("06"), ]
          # sub_pts  <- wr_pts[wr_pts$water_district == as.numeric("06"), ]

          print("Updating leaflet map...")

          # dynamically alter leaflet map
          leaflet::leafletProxy("baseMap") %>%
              leaflet::clearMarkers() %>%
              leaflet::clearShapes() %>%
              leaflet::clearGroup(c("subdist1")) %>%
                # leaflet::removeShape(layerId = levelpathi) %>%
                leaflet::addPolygons(
                      data         = dists,
                      fillColor    = 'white',
                      # fillColor = 'grey',
                      # fillColor = ~pal_fact(BASIN),
                      fillOpacity  = 0.7,
                      col          = "black",
                      opacity      = 1,
                      weight       = 2.5,
                      label        = ~paste0("District: ", DISTRICT),
                      layerId      = ~DISTRICT,
                      labelOptions = leaflet::labelOptions(
                                          noHide = F,
                                          style  = list(
                                            "color" = "black",
                                            "font-weight" = "1000")
                                        )
                  ) %>%
                leaflet::addPolygons(
                    # data         = sub_dist,
                    data = sub_dist1(),
                    fillColor    = '#3EB489',
                    # fillColor = 'grey',
                    # fillColor = ~pal_fact(BASIN),
                    fillOpacity  = 0.5,
                    col          = "black",
                    opacity      = 1,
                    weight       = 3,
                    group        = "subdist1",
                    label        = ~paste0("District: ", DISTRICT),
                    layerId      = ~DISTRICT,
                    labelOptions = leaflet::labelOptions(
                                        noHide = F,
                                        style  = list(
                                          "color" = "black",
                                          "font-weight" = "1000")
                                      )
                )
            # leaflet::addPolylines(
            #   data = area_nhd,
            #   color = "navy",
            #   opacity = 0.9,
            #   stroke = TRUE
            # )
              # leaflet::addCircleMarkers(
              #         data        = sub_pts()[sub_pts()$wdid == input$selectWDID, ],
              #         radius      = 10,
              #         stroke      = FALSE,
              #         color       = "red",
              #         opacity     = 1,
              #         fillColor   = "red",
              #         fillOpacity = 0.7
              #         )
            # leaflet::addCircleMarkers(
            #   data = sub_pts$
            #
            # )

             shiny::observe({

                  if(is.null(dist_id())) {

                       return(NULL)
             #
                     } else {
            
                     # render call date over time plot
                     output$callDatePlot <- shiny::renderPlot({
                       
                        make_avg_yeartype_rightograph_plot(
                          df    = call_year_df(),
                          type  = input$radioYearTypeButtons
                          )

                        })
                       }
               })
             }
          })
```

Row
---------------------------------------------------------
### call date 1
```{r}
shiny::plotOutput("callDatePlot")
```

Regression models 
==========================================

Inputs {.sidebar}
---------------------------------------------------------
```{r, context = "server"}
# ifelse(
#   is.null(predictor_str()),
#   "Select a district to make a provide SWE/NRCS Forecast data...",
#   paste0("Enter ", predictor_str(), " value...")
#        )

shiny::textInput(inputId = "newDataInput", 
                 # label = predictor_label(),
                 label   = "Select a district to make a prediction..",
                 # label   = ifelse(
                 #              is.null(predictor_str()), 
                 #              "Select a district to make a provide SWE/NRCS Forecast data...", 
                 #              paste0("Enter ", predictor_str(), " value...")
                 #                   ),
                 value   = NULL
                 )

shiny::actionButton("newDataInputButton",
                    label = "Predict")

shiny::observeEvent(predictor_label(), {
    shiny::updateTextInput(session, "newDataInput", label = predictor_label())
  })
```

<br>

- ADD TEXT DESCRIBING MODELING PROCESS AND SPECIFIC VARIABLES USED

- Predictor vs Fitted Values is a plot showing the values used to predict average call year (X axis) and the fitted average call year values (Y axis)

- After clicking on a district, you will be shown the R squared value in the middle value box on the top row, and if you type a SWE or NRCS Forecast value into the input box above and press the "Predict" button, a predicted average call year value will be shown in the top right "Predicted" value box

- ADD POPOVERS/TOOLTIPS TO EACH PANEL AS WELL

Row
---------------------------------------------------------
### Dist box
```{r}
flexdashboard::valueBoxOutput("districtValueBox")
```

```{r context="server"}
# {r context="server"}
# flexdashboard::valueBox(value = model_dist_id())
# ("primary", "info", "success", "warning", "danger")
output$districtValueBox <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("District: "),
    color = "primary",
    caption = " "
    )
)

# Value box server
shiny::observeEvent(model_dist_id(), {
# shiny::observeEvent(event_trigger(), {
      # print("observer4")

      # Public Safety value box server
      output$districtValueBox <- flexdashboard::renderValueBox(
        flexdashboard::valueBox(
          value = paste0("District: ", model_dist_id()),
          color = "primary",
          caption = " "
          )
        )

})
```

### R box
```{r}
flexdashboard::valueBoxOutput("rSquaredValueBox")
```

```{r context="server"}
# # flexdashboard::valueBox(value = model_dist_id())
# 
output$rSquaredValueBox <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("R2: "),
    color = "warning",
    caption = " "
    )
)
```

### Predbox
```{r}
# # output prediction value box UI
flexdashboard::valueBoxOutput("predictionValueBox")
```

```{r context="server"}
# # Render the prediction value Value Box
output$predictionValueBox <- flexdashboard::renderValueBox(
  flexdashboard::valueBox(
    value = paste0("Prediction: "),
    color = "success",
    caption = " "
    )
)
```

Row
---------------------------------------------------------
### Model Map
```{r}
leaflet::leafletOutput("modelBaseMap")
```

```{r context="server"}
# # Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# # observeEvent(input$districtMapMLR_click, {
# shiny::observeEvent(input$modelBaseMap_shape_click, {
shiny::observeEvent(input$modelBaseMap_shape_click, {
   if(is.null(model_dist_id())) {

     return(NULL)

   } else {

          pt <- sf::st_as_sf(
                    data.frame(
                      lat = model_map_click()$lat,
                      lng = model_map_click()$lng
                      ),
                    coords = c("lng", "lat"),
                    crs = 4326
                    )
          # 39.7792 -105.7214
          # 40.66392 -105.4837
          # 40.69808 -105.6

          # print(paste0("Subsetting mainstems to HUC4: ",  model_dist_id()))
          print(paste0("PAGE 1 DISTRICT ---> ", model_dist_id()))

          print(paste0("Highlighting district ", model_dist_id(), " based on modelBaseMap polygon CLICK..."))

          # # subset to water district of interest
          # sub_dist <- model_dists[model_dists$DISTRICT == model_dist_id(), ]


          print("Updating leaflet map...")

          # dynamically alter leaflet map
          leaflet::leafletProxy("modelBaseMap") %>%
              leaflet::clearMarkers() %>%
              leaflet::clearShapes() %>%
              leaflet::clearGroup(c("subdist2")) %>%
                # leaflet::removeShape(layerId = levelpathi) %>%
                leaflet::addPolygons(
                      data         = model_dists,
                      fillColor    = 'white',
                      # fillColor = 'grey',
                      # fillColor = ~pal_fact(BASIN),
                      fillOpacity  = 0.7,
                      col          = "black",
                      opacity      = 1,
                      weight       = 2.5,
                      label        = ~paste0("District: ", DISTRICT),
                      layerId      = ~DISTRICT,
                      labelOptions = leaflet::labelOptions(
                                          noHide = F,
                                          style  = list(
                                            "color" = "black",
                                            "font-weight" = "1000")
                                        )
                  ) %>%
                leaflet::addPolygons(
                    data         = sub_dist2(),
                    fillColor    = '#3EB489',
                    # fillColor = 'grey',
                    # fillColor = ~pal_fact(BASIN),
                    fillOpacity  = 0.5,
                    col          = "black",
                    opacity      = 1,
                    weight       = 3,
                    group        = "subdist2",
                    label        = ~paste0("District: ", DISTRICT),
                    layerId      = ~DISTRICT,
                    labelOptions = leaflet::labelOptions(
                                        noHide = F,
                                        style  = list(
                                          "color" = "black",
                                          "font-weight" = "1000")
                                      )
                )

              print(paste0("===== model_dist_id: ", model_dist_id(), " ====="))
              print(paste0("===== predictor_str(): ", predictor_str(), " ====="))
              print(paste0("===== predictor_label(): ", predictor_label(), " ====="))
              print(paste0("- list_id(): ", list_id()))
              print(paste0("- class(model_obj()): ",
                           class(model_obj()))
                    )

               print(paste0("- class(model_data()): ",
                           class(model_data()))
                     )

             shiny::observe({

                  # if(is.null(model_dist_id()) & is.null(dist_mod_df())) {
                  if(is.null(dist_mod_df())) {
                      print(paste0("dist_mod_df is NULL"))

                       return(NULL)
             #
                     } else {

                     # render fitted points plot for clicked district
                     output$fittedPointPlot <- shiny::renderPlot({

                       # make a fitted plot with current model data
                         make_fitted_plot(
                                        df = model_data()
                                        )

                        })

                          # render fitted points plot for clicked district
                     output$predictorFitPlot <- shiny::renderPlot({
                        # make a predictor vs fitted values plot
                        make_predictor_fit_plot(df = model_data())
                          # make_predictor_fit_plot(df = lm_out$model_data)
                        })

                    # Render new R Squared value into value box
                    output$rSquaredValueBox <- flexdashboard::renderValueBox(
                                    flexdashboard::valueBox(
                                      # value = paste0("R2: ", lm_out$r2),
                                      value = paste0("R2: ", lm_data()$r2),
                                      color = "warning",
                                      caption = " "
                                      )
                                  )
                     }


               print(paste0("----> current_district: ", model_dist_id()))

               })

             }
          })
# 
# # # if "predict" button is clicked and there is a value in the newDataInput text box, make a prediction
shiny::observeEvent(input$newDataInputButton, {

        # start_district = model_dist_id()
        # 
        # print(paste0("----> start_district: ", start_district))

        # if an input has been put into text box
        if (!is.null(input$newDataInput)) {

          print(paste0("input$newDataInput: ",input$newDataInput))

          # make a prediction with new data from user input
          pred <- make_prediction(
            model     = model_obj(),
            predictor = predictor_str(),
            val       = as.numeric(input$newDataInput)
          )


          print(paste0("prediction value: ", pred$fitted[1]))

          # update the prediction value Value Box
          output$predictionValueBox <- flexdashboard::renderValueBox(
                          flexdashboard::valueBox(
                            # value = paste0("R2: ", lm_out$r2),
                            value = paste0("Prediction: ", round(pred$fitted, 2)),
                            color = "success",
                            caption = " "
                            )
                        )

          # Update the plot based on the new prediction
          output$predictorFitPlot <- shiny::renderPlot({

            make_new_predfit_plot(
              df = model_data(),
              # df = lm_out$model_data,
              pred_df = pred
            )
          })
        }
      })
```

Row
---------------------------------------------------------

### Predictor vs. Fitted values
```{r}
shiny::plotOutput("predictorFitPlot")
```

### Observed vs. Predicted
```{r}
shiny::plotOutput("fittedPointPlot")
```

